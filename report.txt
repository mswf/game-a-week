<h1><span style="font-size: 22px; line-height: 1.3;">Specialisation (Q3 2015-2016) report by Steff Kempink</span></h1>
Based on the game a week concept. Blablabal placeholder

&nbsp;

[caption id="attachment_224" align="aligncenter" width="466"]<img class="size-full wp-image-224 " alt="SPEC_W04_AI" src="http://kempink.eu/wp-content/uploads/2016/04/W04_AI.gif" width="466" height="283" /> Test subscript[/caption]

Abstract
In this article I will report on the work and results of 8 weekly experimental projects I made. By researching a select amount of AI, physics and procedural generation techniques and applying them in my work I gained a lot of experience in little time. This article will walk you through my weekly (thought)process.
All the results are stored in a public Github repository.

Workflow
I started by reading/researching different concepts through articles, papers and presentations. From this pool of information I chose a concept I wanted to work with more.
Using Unity I would build a working implementation, researching more only when I got stuck. After this was running I would couple it with a crude game concept, just something to give context for any further work.


Week 00
Deciding no subject.
Setting up environment, gather utility libraries I anticipited I would need. Because I limited myself to free and open source assets, many were out of date with Unity's current version. Coupled with my rusty C# memory I spend longer than I wanted fixing issues. 

-DebugDrawingExtension
-DOTween

-GradientMaker

Week 01
Warmup, to get used to C# I decided to just follow tutorials from Catlike Coding. Subject came to multidimensional noise. I envisioned a space nebula you could move through.
Implemented 1D-2D-3D value and perlin noise. Looked into distribution techniques.
http://devmag.org.za/2009/05/03/poisson-disk-sampling/
Found Poisson Disk Sampling, read the theory. Started a mock implementation.
http://theinstructionlimit.com/fast-uniform-poisson-disk-sampling-in-c
Decided to take free distributed C# implementation in 2D. Having the logic already be there sped things up but it still took a while to convert it to 3D and then debug ensuing issues. The algorithm also ate performance as it was calling into native Unity functions. After testing a lot I found it much better to substitute all Math calls with my own one. Profiling showed that calling overhead was reduced by 80%. 
Inspired by the DevMag article, I made the Min and Max Distance of the Poisson Disc sample from the 3D noise. I then spawned particles on these coordinates, again sampling their color from the same noise values.  

On the last day I added a simple spaceship. I rushed in some controls and effects. I had tried making a "chunk" system that i had planned would help me spawn new segments as the player moved, but it didn't solve the real issue of many of the 3D calculations being prohibitevely slow.

Week 02
I started out this week with the goal of planning more gameplay. I wanted to base the game on physics which in retrospect would clearly trip me up. 
The concept was to combine the gameplay from minigolf games with action movies where the hero dodges bullets jumping from desk to desk. Based on previous knowledge I knew I'd need to have a good grip on how the player would move. 
http://gafferongames.com/game-physics/
http://www.gdcvault.com/play/1023559/Math-for-Game-Programmers-Building
So after reading multiple articles I created movement controls. Although the player looks like a capsule, movement is actually based on a free rolling ball. I worked on the input until I could predictibly add the correct amount of force for the ball to roll exactly as far as I designed. However the control didn't feel how I wanted it to, so I spend time trying several different input schemes. The results couldn't satisfy me, so I decided to jump over to work on another part; the shooting and avoiding. This was all very straightforward.
Physics based action game bad idea as I was very inexperienced with Physics. I had to give up on getting the game to work well. I instead doubled down on research to have a better shot at understanding all the requirements the next time something like this would come up.

https://github.com/InfiniteAmmoInc/Yarn
To take my mind off physics for a short while I also read up on the Yarn dialogue engine. Implementing it's Unity interpreter was very straightforward. As a learning excercise I then cracked open the code to see how its developers solved some common problems in dialogue systems using very straightforward solutions.

Week 03
Physics playground
http://gafferongames.com/game-physics/spring-physics/
Inspired by one specific article on spring physics I wanted to replicate it in Unity on top off the existing Physx system. 
Learned debugging, got it to build to Android, burned some time getting Android environment up and running (wanting to get log messages on my laptop from my phone).

Week 04
Android strategy
Made economy
Made factions, with units blabla
Flexible UI
Spend too much time 

Week 05
Behavior Tree

http://gamasutra.com/blogs/ChrisSimpson/20140717/221339/Behavior_trees_for_AI_How_they_work.php

After only reading the article on usage, worked on making my own implementation. I had finished 90% of the functionality I was going to use by Tuesday, but it was very hard to debug all the logic errors in my implementation by stepping through the code. The point of using behavior trees is that they are very tool-friendly, so I resigned myself to creating an in-editor visualization tool for my own implementation as well. 

I had unknowingly started relying on some C# features that ruined build times for Unity.

https://github.com/libgdx/gdx-ai/wiki/Behavior-Trees

I took my first dive into Unity's editor GUI scripting which was surprisingly consistent in it's API compared to other parts of Unity. So after the active paths the agents were taking were being highlighted and I could add visual counters I was able to spend the rest of the week hammering out any remaining issues. On the last day I focused on getting the same rudimentary behaviour from Week04 using this new more flexible system.


Week 06
Doing more with Behavior Trees.
Create squad logic.
Use Unity navmesh.

Had to improve W05 code to be able to visualize multiple agents, share resources and send messages between agents. 

The squad part proved to be too much. After doing more research I found the architecture required to have the flexibility I wanted way out of scope.

Week 07/08
I merged these last weeks because these two weeks would both be cut short and I didn't want to reduce the scope of the last experiments.

Research
spelunky book
http://www.gamasutra.com/blogs/MikeBithell/20140420/215842/Automatic_avoidance_for_player_characters_on_an_indie_budget.php

Added simple hack 'n slash like boxing mechanics. Made a custom character, helped emphasize movements.











